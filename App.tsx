
import React, { useState, useEffect, useRef } from 'react';
import { Search, BookOpen, DownloadCloud, AlertTriangle, Book, RefreshCw, XCircle } from 'lucide-react';
import { fetchChapterList, fetchChapterContent } from './services/geminiService';
import { Chapter, NovelState } from './types';
import ChapterListItem from './components/ChapterListItem';
import ReaderView from './components/ReaderView';

const App: React.FC = () => {
  const [searchInput, setSearchInput] = useState('');
  const [state, setState] = useState<NovelState>({
    title: '',
    chapters: [],
    isFetchingList: false,
    currentChapterId: null,
  });
  const [isBulkFetching, setIsBulkFetching] = useState(false);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);
  
  // Ref to control bulk fetch cancellation
  const abortBulkFetchRef = useRef(false);

  // Scroll to selected chapter content
  useEffect(() => {
    if (state.currentChapterId) {
      const chapter = state.chapters.find(c => c.id === state.currentChapterId);
      // Load if no content and not loading. Allow retry if status is error.
      if (chapter && !chapter.content && chapter.status !== 'loading') {
        loadChapterContent(chapter);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [state.currentChapterId]);

  const handleSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Input Validation
    if (!searchInput.trim()) {
      setErrorMsg("Please enter a novel name.");
      return;
    }
    if (searchInput.trim().length < 2) {
      setErrorMsg("Novel name is too short. Please enter a valid name.");
      return;
    }

    setState(prev => ({ ...prev, isFetchingList: true, title: searchInput, chapters: [], currentChapterId: null }));
    setErrorMsg(null);
    abortBulkFetchRef.current = false; // Reset abort flag
    setIsBulkFetching(false);

    try {
      const titles = await fetchChapterList(searchInput);
      const newChapters: Chapter[] = titles.map((title, index) => ({
        id: crypto.randomUUID(),
        number: index + 1,
        title,
        content: null,
        status: 'pending'
      }));

      setState(prev => ({
        ...prev,
        isFetchingList: false,
        chapters: newChapters,
        currentChapterId: newChapters.length > 0 ? newChapters[0].id : null
      }));
    } catch (error: any) {
      console.error(error);
      setErrorMsg(error.message || "Failed to find novel chapters. Please check the name or try again.");
      setState(prev => ({ ...prev, isFetchingList: false }));
    }
  };

  const loadChapterContent = async (chapter: Chapter) => {
    // Update status to loading
    setState(prev => ({
      ...prev,
      chapters: prev.chapters.map(c => 
        c.id === chapter.id ? { ...c, status: 'loading', errorMessage: undefined } : c
      )
    }));

    try {
      const { content, sourceUrl } = await fetchChapterContent(state.title, chapter.title, chapter.number);
      
      setState(prev => ({
        ...prev,
        chapters: prev.chapters.map(c => 
          c.id === chapter.id ? { ...c, content, status: 'completed', sourceUrl } : c
        )
      }));
    } catch (error: any) {
      console.error(error);
      setState(prev => ({
        ...prev,
        chapters: prev.chapters.map(c => 
          c.id === chapter.id ? { ...c, status: 'error', errorMessage: error.message || "Failed to load" } : c
        )
      }));
    }
  };

  const handleBulkFetch = async () => {
    if (state.chapters.length === 0) return;
    setIsBulkFetching(true);
    abortBulkFetchRef.current = false;

    // Filter for pending or error chapters (retry errors on bulk fetch)
    const pendingChapters = state.chapters.filter(c => !c.content);

    let fetchedCount = 0;

    for (const chapter of pendingChapters) {
      // Check cancellation
      if (abortBulkFetchRef.current) {
        break;
      }
      
      await loadChapterContent(chapter);
      fetchedCount++;
      
      // Small delay to be polite
      if (fetchedCount < pendingChapters.length) {
          await new Promise(r => setTimeout(r, 800));
      }
    }
    
    setIsBulkFetching(false);
    abortBulkFetchRef.current = false;
  };

  const stopBulkFetch = () => {
    abortBulkFetchRef.current = true;
    // UI update handled in the loop exit or manually here if needed immediately
    // but the state `isBulkFetching` will be set to false at end of loop
  };

  const handleExportAll = () => {
    const completedChapters = state.chapters.filter(c => c.content);
    if (completedChapters.length === 0) {
        setErrorMsg("No chapters available to export.");
        return;
    }

    try {
      let fullText = `# ${state.title}\n\nGenerated by NovelWeaver AI\n\n`;
      completedChapters.forEach(c => {
        fullText += `\n\n## Chapter ${c.number}: ${c.title}\n\n${c.content}\n\n***\n`;
      });

      const blob = new Blob([fullText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${state.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}_full.md`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    } catch (e) {
      setErrorMsg("Failed to export file.");
    }
  };

  const navigateChapter = (direction: 'next' | 'prev') => {
    const currentIndex = state.chapters.findIndex(c => c.id === state.currentChapterId);
    if (currentIndex === -1) return;

    const newIndex = direction === 'next' ? currentIndex + 1 : currentIndex - 1;
    if (newIndex >= 0 && newIndex < state.chapters.length) {
      setState(prev => ({ ...prev, currentChapterId: prev.chapters[newIndex].id }));
    }
  };

  const activeChapter = state.chapters.find(c => c.id === state.currentChapterId) || null;
  const activeIndex = state.chapters.findIndex(c => c.id === state.currentChapterId);

  // Count progress
  const completedCount = state.chapters.filter(c => c.status === 'completed').length;
  const totalCount = state.chapters.length;

  return (
    <div className="min-h-screen bg-gray-950 text-gray-100 flex flex-col overflow-hidden">
      {/* Navbar */}
      <header className="h-16 border-b border-gray-800 bg-gray-950 flex items-center px-6 justify-between shrink-0 z-20">
        <div className="flex items-center gap-2">
          <Book className="w-6 h-6 text-blue-500" />
          <h1 className="text-xl font-bold font-serif tracking-tight hidden md:block">NovelWeaver AI</h1>
        </div>
        
        <form onSubmit={handleSearch} className="flex-1 max-w-xl mx-4 md:mx-8">
          <div className="relative group">
            <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-gray-500 group-focus-within:text-blue-400 transition-colors" />
            <input
              type="text"
              value={searchInput}
              onChange={(e) => setSearchInput(e.target.value)}
              placeholder="Enter webnovel name..."
              className="w-full bg-gray-900 border border-gray-800 rounded-full py-2 pl-10 pr-4 text-sm focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all placeholder-gray-600"
            />
          </div>
        </form>

        <div className="flex items-center gap-4">
           {state.chapters.length > 0 && (
             <>
               {isBulkFetching ? (
                 <button 
                    onClick={stopBulkFetch}
                    className="flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium border bg-red-900/20 border-red-800 text-red-300 hover:bg-red-900/40 transition-colors"
                 >
                   <XCircle className="w-3 h-3" /> Stop
                 </button>
               ) : (
                 <button 
                    onClick={handleBulkFetch}
                    disabled={completedCount === totalCount}
                    className={`flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium border transition-colors ${
                       completedCount === totalCount
                        ? 'opacity-50 cursor-not-allowed border-gray-700 text-gray-500'
                        : 'bg-gray-800 border-gray-700 hover:bg-gray-700 text-gray-300'
                    }`}
                 >
                   <RefreshCw className="w-3 h-3" />
                   Fetch All
                 </button>
               )}

               <button 
                  onClick={handleExportAll}
                  className="flex items-center gap-2 px-3 py-1.5 rounded-lg text-xs font-medium bg-blue-600 text-white hover:bg-blue-500 transition-colors"
                >
                  <DownloadCloud className="w-3 h-3" />
                  <span className="hidden md:inline">Export</span>
                </button>
             </>
           )}
        </div>
      </header>

      {/* Main Content */}
      <main className="flex-1 flex overflow-hidden">
        {/* Sidebar: Chapter List */}
        <div className="w-80 bg-gray-900 border-r border-gray-800 flex flex-col shrink-0">
          <div className="p-4 border-b border-gray-800 bg-gray-900 sticky top-0 z-10">
             <div className="flex justify-between items-center mb-2">
               <h2 className="text-sm font-semibold text-gray-400 uppercase tracking-wider">Chapters</h2>
               <span className="text-xs bg-gray-800 px-2 py-0.5 rounded-full text-gray-500">{completedCount} / {totalCount}</span>
             </div>
             {state.chapters.length > 0 && (
               <div className="w-full bg-gray-800 h-1.5 rounded-full overflow-hidden">
                 <div 
                   className={`h-full transition-all duration-500 ${isBulkFetching ? 'bg-blue-400 animate-pulse' : 'bg-blue-500'}`}
                   style={{ width: `${(completedCount / totalCount) * 100}%` }}
                 ></div>
               </div>
             )}
          </div>
          
          <div className="flex-1 overflow-y-auto p-2 space-y-1 scrollbar-thin scrollbar-thumb-gray-700 scrollbar-track-transparent">
             {state.isFetchingList ? (
               <div className="space-y-3 p-2">
                 {[1, 2, 3, 4, 5, 6, 7, 8].map(i => (
                   <div key={i} className="h-10 bg-gray-800 animate-pulse rounded-lg"></div>
                 ))}
               </div>
             ) : state.chapters.length > 0 ? (
               state.chapters.map((chapter) => (
                 <ChapterListItem
                   key={chapter.id}
                   chapter={chapter}
                   isActive={state.currentChapterId === chapter.id}
                   onClick={() => setState(prev => ({ ...prev, currentChapterId: chapter.id }))}
                 />
               ))
             ) : (
                <div className="flex flex-col items-center justify-center h-40 text-gray-600 text-center px-4 mt-10">
                  <BookOpen className="w-8 h-8 mb-2 opacity-50" />
                  <p className="text-sm">Search for a novel to see chapters here.</p>
                </div>
             )}
          </div>
        </div>

        {/* Reader Area */}
        <div className="flex-1 bg-gray-950 p-4 md:p-8 overflow-hidden flex flex-col relative">
          {errorMsg && (
            <div className="absolute top-4 left-1/2 -translate-x-1/2 z-50 bg-red-500/90 backdrop-blur text-white px-6 py-3 rounded-lg shadow-lg flex items-center gap-3 border border-red-400 animate-in slide-in-from-top-2">
              <AlertTriangle className="w-5 h-5 shrink-0" />
              <span className="font-medium">{errorMsg}</span>
              <button 
                onClick={() => setErrorMsg(null)} 
                className="ml-2 hover:bg-white/20 rounded-full p-1"
              >
                <XCircle className="w-4 h-4" />
              </button>
            </div>
          )}
          
          <ReaderView 
            chapter={activeChapter}
            onNavigate={navigateChapter}
            hasPrev={activeIndex > 0}
            hasNext={activeIndex !== -1 && activeIndex < state.chapters.length - 1}
            onRetry={activeChapter?.status === 'error' ? () => loadChapterContent(activeChapter) : undefined}
          />
        </div>
      </main>
    </div>
  );
};

export default App;
